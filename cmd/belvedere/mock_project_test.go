// Code generated by MockGen. DO NOT EDIT.
// Source: ../../pkg/belvedere/belvedere.go

// Package main is a generated GoMock package.
package main

import (
	context "context"
	reflect "reflect"
	time "time"

	belvedere "github.com/codahale/belvedere/pkg/belvedere"
	gomock "github.com/golang/mock/gomock"
)

// MockProject is a mock of Project interface.
type MockProject struct {
	ctrl     *gomock.Controller
	recorder *MockProjectMockRecorder
}

// MockProjectMockRecorder is the mock recorder for MockProject.
type MockProjectMockRecorder struct {
	mock *MockProject
}

// NewMockProject creates a new mock instance.
func NewMockProject(ctrl *gomock.Controller) *MockProject {
	mock := &MockProject{ctrl: ctrl}
	mock.recorder = &MockProjectMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockProject) EXPECT() *MockProjectMockRecorder {
	return m.recorder
}

// Apps mocks base method.
func (m *MockProject) Apps() belvedere.AppService {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Apps")
	ret0, _ := ret[0].(belvedere.AppService)
	return ret0
}

// Apps indicates an expected call of Apps.
func (mr *MockProjectMockRecorder) Apps() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Apps", reflect.TypeOf((*MockProject)(nil).Apps))
}

// DNSServers mocks base method.
func (m *MockProject) DNSServers(ctx context.Context) ([]belvedere.DNSServer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DNSServers", ctx)
	ret0, _ := ret[0].([]belvedere.DNSServer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DNSServers indicates an expected call of DNSServers.
func (mr *MockProjectMockRecorder) DNSServers(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DNSServers", reflect.TypeOf((*MockProject)(nil).DNSServers), ctx)
}

// Instances mocks base method.
func (m *MockProject) Instances(ctx context.Context, app, release string) ([]belvedere.Instance, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Instances", ctx, app, release)
	ret0, _ := ret[0].([]belvedere.Instance)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Instances indicates an expected call of Instances.
func (mr *MockProjectMockRecorder) Instances(ctx, app, release interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Instances", reflect.TypeOf((*MockProject)(nil).Instances), ctx, app, release)
}

// Logs mocks base method.
func (m *MockProject) Logs() belvedere.LogService {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Logs")
	ret0, _ := ret[0].(belvedere.LogService)
	return ret0
}

// Logs indicates an expected call of Logs.
func (mr *MockProjectMockRecorder) Logs() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Logs", reflect.TypeOf((*MockProject)(nil).Logs))
}

// MachineTypes mocks base method.
func (m *MockProject) MachineTypes(ctx context.Context, region string) ([]belvedere.MachineType, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MachineTypes", ctx, region)
	ret0, _ := ret[0].([]belvedere.MachineType)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MachineTypes indicates an expected call of MachineTypes.
func (mr *MockProjectMockRecorder) MachineTypes(ctx, region interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MachineTypes", reflect.TypeOf((*MockProject)(nil).MachineTypes), ctx, region)
}

// Name mocks base method.
func (m *MockProject) Name() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Name")
	ret0, _ := ret[0].(string)
	return ret0
}

// Name indicates an expected call of Name.
func (mr *MockProjectMockRecorder) Name() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Name", reflect.TypeOf((*MockProject)(nil).Name))
}

// Releases mocks base method.
func (m *MockProject) Releases() belvedere.ReleaseService {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Releases")
	ret0, _ := ret[0].(belvedere.ReleaseService)
	return ret0
}

// Releases indicates an expected call of Releases.
func (mr *MockProjectMockRecorder) Releases() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Releases", reflect.TypeOf((*MockProject)(nil).Releases))
}

// Secrets mocks base method.
func (m *MockProject) Secrets() belvedere.SecretsService {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Secrets")
	ret0, _ := ret[0].(belvedere.SecretsService)
	return ret0
}

// Secrets indicates an expected call of Secrets.
func (mr *MockProjectMockRecorder) Secrets() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Secrets", reflect.TypeOf((*MockProject)(nil).Secrets))
}

// Setup mocks base method.
func (m *MockProject) Setup(ctx context.Context, dnsZone string, dryRun bool, interval time.Duration) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Setup", ctx, dnsZone, dryRun, interval)
	ret0, _ := ret[0].(error)
	return ret0
}

// Setup indicates an expected call of Setup.
func (mr *MockProjectMockRecorder) Setup(ctx, dnsZone, dryRun, interval interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Setup", reflect.TypeOf((*MockProject)(nil).Setup), ctx, dnsZone, dryRun, interval)
}

// Teardown mocks base method.
func (m *MockProject) Teardown(ctx context.Context, dryRun, async bool, interval time.Duration) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Teardown", ctx, dryRun, async, interval)
	ret0, _ := ret[0].(error)
	return ret0
}

// Teardown indicates an expected call of Teardown.
func (mr *MockProjectMockRecorder) Teardown(ctx, dryRun, async, interval interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Teardown", reflect.TypeOf((*MockProject)(nil).Teardown), ctx, dryRun, async, interval)
}
